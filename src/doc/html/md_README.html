<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Network Backup: NETBACK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Network Backup
   </div>
   <div id="projectbrief">Secure backups over network</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Pagina&#160;Principale</span></a></li>
      <li class="current"><a href="pages.html"><span>Pagine&#160;collegate</span></a></li>
      <li><a href="annotated.html"><span>Strutture&#160;dati</span></a></li>
      <li><a href="files.html"><span>File</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Cerca" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NETBACK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h4>Software di trasferimento e salvataggio file attraverso la rete.</h4>
<h2>Presentazione del software</h2>
<p>Il software si presenta diviso in cinque eseguibili compilati, scritti in linguaggio C/C++ , ed uno script python, in quanto le sue funzionalità comprendono maggiormente lo scambio di dati in rete. Lo scopo del software è il salvataggio di copie di backup di file e drive fisici attraverso la rete e la loro memorizzazione all’interno di un server preposto, senza utilizzare spazio sul disco fisico della macchina client. La dotazione di un pannello di controllo con interfaccia web sicura permette l’utilizzo in reti di discrete dimensioni puntando sulla facilità di controllo dei client agli amministratori di rete.</p>
<h2>Funzionalità</h2>
<h3>Controllo dell’identità del server mediante RSA</h3>
<p>Il primo controllo del client nei confronti del server consiste nella verifica dell’identità della macchina mediante la firma digitale possibile grazie all’algoritmo RSA. Al momento della configurazione del server verrà creata una coppia di chiavi (Pubblica e Privata) contenente le informazioni relative ai valori per compiere i passaggi di firmatura: questi dati sono contenuti nel file “keys.rsacfg” (Configurazione di default). Come Visibile dall’immagine a lato, se il client possiede già una copia della chiave pubblica del server, procederà all’invio di una stringa di 16 caratteri che verrà firmata digitalmente dal server, per poi essere rispedita al mittente e verificata. Se la verifica dovesse avere esito negativo, il server sarebbe giudicato non attendibile e di conseguenza la connessione non assicura la riservatezza dei dati. Questo previene attacchi del tipo “Man In The Middle”.</p>
<h3>Crittografia AES ECB a 256 bit</h3>
<p>Se definito nel file di configurazione del client, il file trasmesso sarà cifrato mediante AES 256. La crittografie prende parte all’invio del file a blocchi di lunghezza configurabile ma multiplo di 16, dimensione del blocco AES. Il server si limiterà a salvare il file così come viene inviato, e, mediante un eseguibile di utilità, i file potranno essere decifrati e salvati correttamente. </p><h3>Integrità della trasmissione</h3>
<p>La connessione TCP implementa nativamente la ricezione del pacchetto con risposta (ACK) e verifica di integrità dei dati tramite CRC32 </p><h3>Gestione dello spazio su disco</h3>
<p>All’atto della ricezione del pacchetto, il server, salverà sul disco fisso i dati, e se specificato nel file di configurazione, il contenuto del pacchetto verrà compresso con l’algoritmo BZip2, mantenendo l’occupazione in memoria Ram limitata fissando un limite massimo di dimensione del file prima di essere zippato e scaricato sul disco. </p><h3>Terminale di gestione interno</h3>
<p>Un processo adibito alle funzioni di terminale filtra lo stream STDIN ed esegue i comandi caricandoli al momento come librerie dinamiche. Prima di caricare il codice, per prevenire l’esecuzione di codice malevolo, il file viene verificato mediante il processo di firma digitale utilizzato per la verifica dell’identità del server. In questo caso una CA (Certificate Authority) viene generata (set di chiavi) al momento della compilazione, per ragioni di sicurezza, la chiave privata e pubblica non dovranno mai esistere sullo stesso hard disk. </p><h3>Shell SSH</h3>
<p>Se impostato al momento della creazione, il server creerà un processo per la gestione delle connessioni SSHv1 e SSHv2 sulle quali verranno reindirizzati gli stream di I/O del terminale. Questo soltanto se al momento della creazione riesce la creazioni di chiavi RSA e DSA atte alla gestione della shell sicura. </p><h3>Pannello di controllo web</h3>
<p>Lo script python distribuito consente l’apertura di una porta con web server per il controllo dello stato dei backup in corso sul server e la possibilità di gestire il traffico dati. Implementato nel server vi è un controllo sugli host in grado di usufruire delle operazioni di gestione. Se l’host su cui viene eseguito il web server è incluso nella suddetta lista, allora potrà accedere ai dati relativi allo stato dei backup. Il web server è configurabile per richiedere l’autenticazione dell’utente, ed è possibile utilizzarlo sotto connessione protetta HTTPS. L’utilizzo dell’API websocket richiede che la connessione venga effettuata da un client Google Chrome o derivati implementanti l’API. </p><h2>Utilità</h2>
<p>All’atto della compilazione verranno generati tre eseguibili e un file di configurazione rsa che, bensì situati in altre directory, per motivi di sicurezza è fortemente consigliata la separazione fisica degli eseguibili su diverse macchine. È di conseguenza consigliata la cancellazione degli eseguibili di utilità dal server e mantenerli su una seconda macchina possibilmente non raggiungibile dalla rete del server, in quanto il file di configurazione rsa (CA.rsacfg) contiene la chiave privata per la segnatura dei comandi.</p>
<h3>./genPasswd - Codificatore di password</h3>
<p><b>SINTASSI: ./genPasswd &lt;password&gt; OUTPUT: l’hash generato relativo al parametro &lt;password&gt; inserito e la chiave codificata.</b></p>
<p>La sessione ssh verificherà l’autenticazione di un solo utente dati il suo nome utente e l’hash della password. Al momento della convalida delle credenziali, il server verificherà le coincidenze del nome utente, l’hash salvato e fornito al momento della configurazione e l’hash della password inserita dall’utente generato runtime. Al momento della configurazione, dopo aver generato il corrispondente hash sarà necessario trascrivere l’output del programma nel file di configurazione. </p><h3>./signElf - Firma digitale dei comandi</h3>
<p><b>SINTASSI: ./signElf &lt;percorso/al/comando&gt; OUTPUT: none</b></p>
<p>Per verificare l’attendibilità prima dell’esecuzione di un programma il server verificherà la firma digitale del file generata da signElf. La firma verrà aggiunta in coda all’eseguibile e consisterà nella rappresentazione esadecimale dell’hash del file segnato digitalmente con la chiave privata dell’autorità di certificazione. Una volta svincolato il dato dalla firma digitale mediante la chiave pubblica salvata, il risultato verrà confrontato con l’hash del file (Firma esclusa). Se gli hash variassero il comando non verrebbe eseguito perché modificato.</p>
<h3>./baknfo​ ​-​ ​Informazioni​ ​di​ ​backup</h3>
<p>Il​ ​tool​ ​stamperà​ ​a​ ​schermo​ ​le​ ​informazioni​ ​relative​ ​al​ ​file​ ​head.hd​ ​nella directory​ ​del​ ​backup.</p>
<h3>./extract_all - Estrazione​ ​di​ ​tutti​ ​i​ ​file​ ​crittografati</h3>
<p><b>SINTASSI:​ ​./extract_all​ ​&lt;directory ​="" ​del​="" ​backup&gt;=""&gt;​ ​&lt;packet_lenght&gt;​ ​&lt;key&gt; OUTPUT:​ ​none</b></p>
<p>Il​ ​funzionamento​ ​viene​ ​illustrato​ ​nel​ ​capitolo​ ​“./extract​ ​-​ ​Estrazione​ ​dei​ ​file crittografati”​ ​e​ ​viene​ ​eseguito​ ​su​ ​tutti​ ​i​ ​file​ ​con​ ​estensione​ ​“*.bak”.</p>
<h3>./extract - Estrazione dei file crittografati</h3>
<p><b>SINTASSI: ./extract &lt;input_file&gt; &lt;packet_lenght&gt; &lt;key&gt; [output_file] OUTPUT: none</b></p>
<p>Durante l’esecuzione, l’applicazione legge dal file &lt;input_file&gt; a blocchi di &lt;packet_lenght&gt;. Quest’ultimo deve equivalere al valore (transfer_block_size x 16) Una volta letto l’header del file, con definizione dei parametri quali la lunghezza del file e se quest’ultimo sia cifrato, verrà creato un file chiamato [output_file] oppure, se non definito, verrà creato un file con il nome definito nell’header di trasmissione nella directory di esecuzione dell’applicazione. Nel caso il file sarà cifrato, il salvataggio avverà in chiaro. Nel caso vi fossero due file salvati con lo stesso nome, essi verranno salvati con il suffisso "-_&lt;variante&gt;"</p>
<h2>Gestione delle connessioni</h2>
<p>Dopo le procedure di avvio, il server effettuerà le operazioni di binding sulla porta specificata nei parametri di configurazione. La connessione con il server viene avviata come connessione UDP e i client comunicheranno con la macchina mediante pacchetti di 19 byte così definiti:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div><div class="line"><span class="keywordtype">char</span> magic_word[2];</div><div class="line"><span class="keywordtype">char</span> data[17];</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed));</div></div><!-- fragment --><p>dove i caratteri magic_word costituiscono l’identificatore del pacchetto e il valore semantico da attribuire ai dati presenti in data. Una volta stabilita una connessione client/server e una volta gestita una richiesta di backup, il server creerà un processo con memoria condivisa, per la gestione del backup, tramite la chiamata mmap che aprirà una porta TCP nell’intervallo configurato e la comunicherà al client. Le connessioni relative al terminale remoto utilizzato dall’interfaccia web vengono filtrate e gestite come pacchetti normali con identificatore ad hoc, mentre la gestione relativa all’interfaccia SSH viaggia su una connessione TCP over TSL con certificato ssh. </p><h2>Processo di backup</h2>
<h3>Salvataggio</h3>
<p>Una volta effettuata la richiesta di backup, in risposta verrà emanato un pacchetto contenente il numero di porta sulla quale iniziare una comunicazione TCP. Una volta stabilita una connessione sulla porta indicata, il client invierà un header di backup contenente il client, il numero di file che verranno trasmessi e altre informazioni di utilità informativa per il flusso del programma. Il backup sarà salvato in una directory all’interno della cartella predefinita, seguendo la nomenclatura &lt;client ip&gt;=""&gt;_&lt;unix timestamp&gt;/. Dopo la trasmissione delle informazioni preliminari ha inizio la trasmissione dei file, con la trasmissione di un file_header con la lunghezza di trasmissione e informazioni riguardo se quest’ultimo sia cifrato, il nome originale e la data di invio. I file vengono quindi salvati man mano che arrivano dalla rete per evitare sovraffollamento di dati nella ram. Se venissero inviati due file aventi lo stesso nome, essi verranno concatenati nello stesso file su disco. </p><h3>Ripristino</h3>
<p>Una volta estratto il file (Se quest’ultimo presenta l’estensione .bz2) viene lanciato il software di estrazione. Una volta letta l’intestazione del file, l’eseguibile scriverà il contenuto su un file specificato in modo binario.</p>
<h2>Headers e strutture</h2>
<p>Definiti in Headers.h</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div><div class="line">   <span class="keywordtype">char</span> mw[2];</div><div class="line">   <span class="keywordtype">char</span> data[17];</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed)) packet;</div></div><!-- fragment --><p> La struttura rappresenta il pacchetto ricevuto dal server UDP e comprende due campi mw (L’identificatore del tipo) e data contenente i dati scambiati da interpretare in conseguenza del valore mw. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div><div class="line">   <span class="keywordtype">int</span> explen;</div><div class="line">   <span class="keywordtype">int</span> nlen;</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed)) <a class="code" href="structpkey__identifier__t.html">pkey_identifier_t</a>;</div></div><!-- fragment --><p> La struttura rappresenta la sequenza di dati nello scambio di una chiave pubblica. Essendo quest’ultima composta da due valori E ed N, la struttura mantiene le lunghezze dei dati, mentre al momento dell’invio verrà inviata la struttura seguita da explen+nlen byte contenenti i valori. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>{</div><div class="line">   uint8_t parts[4];</div><div class="line">   uint32_t ip;</div><div class="line">}<a class="code" href="unionipAddr.html">ipAddr</a>;</div></div><!-- fragment --><p> <a class="el" href="unionipAddr.html">ipAddr</a> è l’unione utilizzata per la rappresentazione di un indirizzo ip e nel suo confronto: per la stampa viene utilizzato il vettore di interi a 8 bit rappresentanti i byte di un indirizzo ipv4, mentre per il confronto verrano utilizzati i numeri per incrementare le prestazioni su liste lunghe. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">   <a class="code" href="unionipAddr.html">ipAddr</a> address;</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> netMask;</div><div class="line">}<a class="code" href="structnetwork.html">network</a> ;</div></div><!-- fragment --><p>Una rete verrà salvata con la coppia di dati address e netmask, quest’ultima vista come intero data la sua unica utilità nell’operazione logica di verifica rete.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div><div class="line">   <span class="keywordtype">int</span> server_port;</div><div class="line">   <span class="keywordtype">int</span> starting_port;</div><div class="line">   <span class="keywordtype">int</span> port_interval;</div><div class="line">   <span class="keywordtype">int</span> ToZip;</div><div class="line">   uint64_t maxRamAmount;</div><div class="line">   <span class="keywordtype">int</span> allowEqualsDeny_nets;</div><div class="line">   <span class="keywordtype">int</span> allowEqualsDeny_ips;</div><div class="line">   <span class="keywordtype">int</span> netsNo;</div><div class="line">   <a class="code" href="structnetwork.html">network</a> * networks;</div><div class="line">   <span class="keywordtype">int</span> ipsNo;</div><div class="line">   <a class="code" href="unionipAddr.html">ipAddr</a> * ips;</div><div class="line">   <span class="keywordtype">int</span> manNo;</div><div class="line">   <a class="code" href="unionipAddr.html">ipAddr</a> * mans;</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed)) <a class="code" href="structconf.html">conf</a>;</div></div><!-- fragment --><p>La struttura detiene i dati relativi alla configurazione del server e, una volta compilata in memoria, verrà passato il suo puntatore ai sottoprocessi di backup e di terminale per accedere alle configurazioni. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">   <span class="keywordtype">int</span> socket;</div><div class="line">   <span class="keywordtype">int</span> port;</div><div class="line">   sockaddr client;</div><div class="line">   uint64_t dimension;</div><div class="line">   uint64_t transferred;</div><div class="line">   <span class="keywordtype">int</span> numberOfFiles;</div><div class="line">   <span class="keywordtype">int</span> filesTransferred;</div><div class="line">   time_t startedInTime;</div><div class="line">   <span class="keywordtype">int</span> status;</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed)) <a class="code" href="structbackupThread.html">backupThread</a>;</div></div><!-- fragment --><p>La struttura rappresenta lo stato in un istante di lettura di un processo di backup. Essa contiene il numero identificativo socket in caso di operazioni da terminale come la chiusura immediata o la pausa. Contiene i dati utili alla rappresentazione degli stati come percentuali. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div><div class="line">   <span class="keywordtype">int</span> port;</div><div class="line">   <span class="keywordtype">char</span> * user;</div><div class="line">   <span class="keywordtype">char</span> * password;</div><div class="line">   <span class="keywordtype">char</span> * rsa;</div><div class="line">   <span class="keywordtype">char</span> * dsa;</div><div class="line">   <span class="keywordtype">int</span> usepcap;</div><div class="line">   <span class="keywordtype">char</span> * pcap;</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed)) <a class="code" href="structsshconf.html">sshconf</a>;</div></div><!-- fragment --><p>La struttura mantiene le referenze per le configurazioni del terminale SSH </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div><div class="line">   <span class="keywordtype">int</span> isEncoded;</div><div class="line">   sockaddr_in client;</div><div class="line">   <span class="keywordtype">int</span> numberOfFiles;</div><div class="line">   time_t time;</div><div class="line">   <span class="keywordtype">int</span> packetSize;</div><div class="line">   <span class="keywordtype">char</span> foo[32];</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed)) <a class="code" href="structbackupHead__t.html">backupHead_t</a>;</div></div><!-- fragment --><p>La struttura descrive l’intestazioni dei file head.hd relativi alle informazioni di backup. le informazioni memorizzate sono: Se i file seguenti saranno cifrati, L’indirizzo del client, Il numero di file nel backup, Il timestamp di avvio del processo, La dimensione del pacchetto di trasmissione, 32 byte di padding per contenere future addizioni. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div><div class="line">   uint64_t dimension;</div><div class="line">   uint64_t transfer_dimension;</div><div class="line">   <span class="keywordtype">int</span> isEncoded;</div><div class="line">   time_t time;</div><div class="line">   <span class="keywordtype">char</span> name[50];</div><div class="line">   <span class="keywordtype">char</span> foo[32];</div><div class="line">}<a class="code" href="struct____attribute____.html">__attribute__</a>((packed)) <a class="code" href="structfile__h.html">file_h</a>;</div></div><!-- fragment --><p>La struttura definisce le intestazioni dei file salvati. Essa contiene informazioni quali: Dimensioni del file in chiaro Dimensioni del file scritto sul disco (non compresso), questo perché se il file fosse cifrato le dimensioni dovranno essere multiplo di 16 e, nel caso non lo fossero verranno aggiunti n byte di padding Se il file è cifrato La data di trasmissione come timestamp Il nome originale 32 byte di padding per contenere future addizioni. Crittografia Gli algoritmi implementati per la cifratura e la verifica della sicurezza sono: AES ECB 256bit per la cifratura dei file RSA per la verifica delle identità dei file, utilizzando chiavi generate Una variante di md5 per motivi di semplicità di codice.</p>
<h2>Formati file</h2>
<h3>*.rsacfg</h3>
<p>Il formato rsacfg è un formato testuale utilizzato per la descrizione di una coppia di chiavi RSA. Siano nominati i parametri di una coppia di chiavi RSA</p><ul>
<li>“P” e “Q” la coppia di numeri primi generati</li>
<li>“N” il modulo</li>
<li>“E” l’esponente pubblico</li>
<li>“D” l’esponente privato</li>
<li>I dati contenuti saranno separati dal carattere ‘<br />
’ e memorizzati nel seguente ordine in rappresentazione esadecimale: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;P (\n)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Q (\n)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;N (\n)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;E (\n)</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;D (\n)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;(EOF)</div></div><!-- fragment --> <h3>*.public</h3>
</li>
</ul>
<p>Il formato public è un formato testuale utilizzato per la descrizione di una chiave RSA pubblica ed è una variante del formato rsacfg. Siano nominati i parametri di una chiave RSA pubblica</p><ul>
<li>“N” il modulo</li>
<li>“E” l’esponente pubblico</li>
</ul>
<p>I dati contenuti saranno separati dal carattere ‘<br />
’ e memorizzati nel seguente ordine in rappresentazione esadecimale: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;N (\n)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;E (\n)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;(EOF)</div></div><!-- fragment --> <h3>*.bak</h3>
<p>Il formato bak è il formato con cui vengono memorizzati i file sul disco una volta trasferiti. Viene memorizzato in formato binario ed è costituito da uno o più moduli concatenati fra loro e definiti in questo modo: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;File Header (vedi  file_h in Header e Strutture)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Contenuto inviato</div></div><!-- fragment --><p> Di conseguenza il file in memoria sarà così strutturato: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;File Header</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Contenuto inviato</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;File Header</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Contenuto inviato</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;File Header</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Contenuto inviato</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;(EOF)</div></div><!-- fragment --> <h3>*.hd</h3>
<p>I file in formato hd contengono le informazioni generali di un backup e contengono una sola struttura backupHeader_t (vedi Header e Strutture)</p>
<h2>Compilazione</h2>
<p>L’esecuzione del Makefile comprende le seguenti fasi: Creazione dello scheletro directory per i programmi Copia dei file generici e degli script Generazione dei certificati e delle chiavi Compilazione dei comandi Compilazione</p>
<h2>Comandi</h2>
<p>Ogni comando compilato deve seguire le seguenti specifiche. </p><h3>Modello</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Headers.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> execute(<span class="keywordtype">char</span> * args, backupThread * back, conf * cfgs,</div><div class="line"><span class="keywordtype">int</span> (*print_f)(<span class="keyword">const</span> <span class="keywordtype">char</span> *, ...)){</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> PER ANSI-C</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &quot;Headers.h&quot;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;string.h&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;extern “C” int execute(char * args, backupThread * back, conf * cfgs,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;int (*print_f)(const char *, ...)){</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;return 0;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><p> PER C++</p>
<p>È obbligatoria la presenza di un metodo execute ritornante int. L’inclusione di Headers.h è obbligatoria in quanto definisce tutte le strutture passate come argomenti alla funzione execute. I parametri passati ad execute saranno: args: È una stringa contenente i parametri passati dalla linea di comando del terminale back: Un puntatore al vettore di lunghezza cfgs-&gt;port_interval contenente lo stato dei backup, chi è connesso è la quantità di dati trasferita. cfgs: Un puntatore alla struttura dove risiedono le configurazioni del server print_f: una funzione che permette la stampa sullo stream predefinito, sia il terminale in finestra o tramite SSH. La sintassi è la stessa che per printf e il ritorno è il numero di caratteri scritti.</p>
<h3>Compilazione</h3>
<p>Con il comando </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gcc &lt;file.c&gt; --shared -fPIC -o &lt;file&gt;</div></div><!-- fragment --><p> Oppure </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;g++ &lt;file.c&gt; --shared -fPIC -o &lt;file&gt;</div></div><!-- fragment --><p> Rispettando il modello per il linguaggio adeguato</p>
<h2>Configurazione</h2>
<p>config.properties</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#Commento</div></div><!-- fragment --><p> Le righe con ‘::’ iniziale vengono ignorate </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;port = 5577</div></div><!-- fragment --><p> Porta dove sarà situato il server UDP </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;startingPort = 11000</div></div><!-- fragment --><p> Prima porta per i processi di backup </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;interval = 100</div></div><!-- fragment --><p> Numero massimo di processi contemporanei. verranno utilizzate le porte dalla startingPort alla startingport+interval. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;rsaConfig = keys.rsacfg</div></div><!-- fragment --><p> File di configurazione delle chiavi RSA del server atte all’identificazione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;zipFiles = 1</div></div><!-- fragment --><p> Se diverso da 0 i file ricevuti saranno compressi. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;maxRamAmount = 3000000</div></div><!-- fragment --><p> La dimensione massima di un file memorizzato in memoria RAM prima della compressione: se quest’ultimo supera questa dimensione, il file non sarà compresso. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;networks_blacklist = 0</div></div><!-- fragment --><p> Se diverso da 0 le reti elencate non saranno autorizzate alla connessione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;networks = :</div></div><!-- fragment --><p> Inizia la lista di reti autorizzate (A meno di un valore positivo per network_blacklist) </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;192.168.0.0/24</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;135.144.1.0/24</div></div><!-- fragment --><p> Contenuto della lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;::</div></div><!-- fragment --><p> Termina la lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ips_blacklist = 0</div></div><!-- fragment --><p> Se diverso da 0 gli host elencati non saranno autorizzati alla connessione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ips = :</div></div><!-- fragment --><p> inizia la lista di host autorizzati (A meno di un valore positivo per ips_blacklist) </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;127.0.0.1</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;192.168.43.177</div></div><!-- fragment --><p> Contenuto della lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;::</div></div><!-- fragment --><p> Termina la lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;managers = :</div></div><!-- fragment --><p> inizia la lista di host autorizzati all’utilizzo del terminale di rete </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;127.0.0.1</div></div><!-- fragment --><p> Contenuto della lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;::</div></div><!-- fragment --><p> Termina la lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;use_ssh = 1</div></div><!-- fragment --><p> Un valore diverso da 0 abilita la shell SSH </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ssh_user = stefano</div></div><!-- fragment --><p> Indica il nome utente con cui sarà possibile connettersi alla shell ssh </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ssh_psw_md5 = a9d4eff9120382f59fb2d971ca96a85a</div></div><!-- fragment --><p> Indica l’hash della password, generato con l’utility ./genPasswd, prendendo la chiave “HASH”, da utilizzare per l’accesso tramite SSH. Il confronto avverrà tra l’hash memorizzato e l’hash della stringa inserita dall’utente. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ssh_port = 2222</div></div><!-- fragment --><p> Numero della porta dove servire il servizio di SSH </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ssh_rsa = ./ssh_keys/ssh_host_rsa_key</div></div><!-- fragment --><p>Directory relativa all’avvio dove risiede la chiave RSA per la connessione SSH </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ssh_dsa = ./ssh_keys/ssh_host_dsa_key</div></div><!-- fragment --><p> Directory relativa all’avvio dove risiede la chiave DSA per la connessione SSH</p>
<p>client.properties </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#Commento</div></div><!-- fragment --><p> Le righe con ‘::’ iniziale vengono ignorate </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;server_ip = 127.0.0.1</div></div><!-- fragment --><p> l’indirizzo IPv4 del server a cui connettersi </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;server_port = 5577</div></div><!-- fragment --><p> Porta sulla quale contattare il server: dovrebbe corrispondere al parametro port in config.properties relativo al server </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;connection_timeout = 10</div></div><!-- fragment --><p> Timeout di connessione in secondi </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;files = :</div></div><!-- fragment --><p> inizia la lista di file da trasmettere </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/home/.../a.jpg</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/home/.../b.pdf</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/usr/bin/</div></div><!-- fragment --><p> Contenuto dell lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;::</div></div><!-- fragment --><p> Termina la lista </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;encrypt = 1</div></div><!-- fragment --><p>Un valore diverso da 0 determina che i file verranno cifrati con algoritmo AES ECB 256bit prima dell’invio </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;transfer_block_size = 32</div></div><!-- fragment --><p> Indica il quantitativo in blocchi AES (16 byte l’uno) di byte da inviare per volta: il totale sarà dato dal valore moltiplicato per 16 </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;key = KFXU2SRTM5DXG6TLM5TEKVDQNJKHEWTLGRDDQYRZMVSXSYJXJVQWC===</div></div><!-- fragment --><p> È la chiave di cifratura del file codificata come base32, generabile mediante l’utility ./genPasswd prendendo il parametro “Encoded key” </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;send_interval = 500</div></div><!-- fragment --><p> Intervallo, in millisecondi, nella trasmissione dei pacchetti. Utile per la riduzione del carico della cpu</p>
<h2>Librerie esterne</h2>
<ul>
<li><a href="https://gmplib.org/">libgmp</a> (GNU MULTIPLE PRECISION arithmetic library)</li>
<li><a href="http://www.bzip.org/">libbz2</a> (Compressione dei file)</li>
<li><a href="https://www.libssh.org/">libssh</a> (Secure shell) </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generato da &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
